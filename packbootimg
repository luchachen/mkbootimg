#!/usr/bin/env python
# Copyright 2015, The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import print_function
from sys import argv, exit, stderr
from argparse import ArgumentParser, FileType, Action
import os
from os import fstat
from os.path import basename, dirname,join
from struct import pack,unpack, calcsize
from hashlib import sha1
import sys
import re
import json
import glob
from subprocess import *
import shutil
import pprint

ARMV8MAGIC='\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\xb7\x00\x01\x00\x00\x00'

def getscript():
    return os.path.abspath(os.path.dirname(os.path.realpath(__file__)))

def filesize(f):
    if f is None:
        return 0
    try:
        return fstat(f.fileno()).st_size
    except OSError:
        return 0


def update_sha(sha, f):
    if f:
        sha.update(f.read())
        f.seek(0)
        sha.update(pack('I', filesize(f)))
    else:
        sha.update(pack('I', 0))


def pad_file(f, padding):
    pad = (padding - (f.tell() & (padding - 1))) & (padding - 1)
    f.write(pack(str(pad) + 'x'))


def write_header(args):
    BOOT_MAGIC = 'ANDROID!'.encode()
    args.output.write(pack('8s', BOOT_MAGIC))
    args.output.write(pack('10I',
        filesize(args.kernel),                          # size in bytes
        args.base + args.kernel_offset,                 # physical load addr
        filesize(args.ramdisk),                         # size in bytes
        args.base + args.ramdisk_offset,                # physical load addr
        filesize(args.second),                          # size in bytes
        args.base + args.second_offset,                 # physical load addr
        args.base + args.tags_offset,                   # physical addr for kernel tags
        args.pagesize,                                  # flash page size we assume
        filesize(args.dt),                              # size in bytes
        (args.os_version << 11) | args.os_patch_level)) # os version and patch level
    args.output.write(pack('16s', args.board.encode())) # asciiz product name
    args.output.write(pack('512s', args.cmdline[:512].encode()))

    sha = sha1()
    update_sha(sha, args.kernel)
    update_sha(sha, args.ramdisk)
    update_sha(sha, args.second)
    update_sha(sha, args.dt)
    img_id = pack('32s', sha.digest())

    args.output.write(img_id)
    args.output.write(pack('1024s', args.cmdline[512:].encode()))
    pad_file(args.output, args.pagesize)
    return img_id


class ValidateStrLenAction(Action):
    def __init__(self, option_strings, dest, nargs=None, **kwargs):
        if 'maxlen' not in kwargs:
            raise ValueError('maxlen must be set')
        self.maxlen = int(kwargs['maxlen'])
        del kwargs['maxlen']
        super(ValidateStrLenAction, self).__init__(option_strings, dest, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        if len(values) > self.maxlen:
            raise ValueError('String argument too long: max {0:d}, got {1:d}'.
                format(self.maxlen, len(values)))
        setattr(namespace, self.dest, values)


def write_padded_file(f_out, f_in, padding):
    if f_in is None:
        return
    f_out.write(f_in.read())
    pad_file(f_out, padding)


def parse_int(x):
    return int(x, 0)

def parse_os_version(x):
    match = re.search(r'^(\d{1,3})(?:\.(\d{1,3})(?:\.(\d{1,3}))?)?', x)
    if match:
        a = int(match.group(1))
        b = c = 0
        if match.lastindex >= 2:
            b = int(match.group(2))
        if match.lastindex == 3:
            c = int(match.group(3))
        # 7 bits allocated for each field
        assert a < 128
        assert b < 128
        assert c < 128
        return (a << 14) | (b << 7) | c
    return 0

def parse_os_patch_level(x):
    match = re.search(r'^(\d{4})-(\d{2})-(\d{2})', x)
    if match:
        y = int(match.group(1)) - 2000
        m = int(match.group(2))
        # 7 bits allocated for the year, 4 bits for the month
        assert y >= 0 and y < 128
        assert m > 0 and m <= 12
        return (y << 4) | m
    return 0

class JSONAction(Action):
    """An argparse action that concatenates "-i" "INPUT" """

    def __call__(self, parser, namespace, value, name):
        setattr(namespace, self.dest, value)
        try:
            _dict = json.load(value)

            print('json %s:' % value.name)
            #pprint.pprint(_dict, indent = 4)
            for k, v in _dict.items():
                if v is not None:
                    setattr(namespace, k, v)
            (_prefix, _ext) = basename(value.name).split('-')
            _prefix = join(dirname(value.name),_prefix)
            mfns = glob.glob(_prefix+'-zImage')
            if len(mfns) > 1:
                print('warning: too many files %s' % mfns)
            setattr(namespace, 'kernel', open(mfns[0]))
            mfns =glob.glob(_prefix+'-ramdisk.*')
            if len(mfns) > 1:
                print('warning: too many files %s' % mfns)
            setattr(namespace, 'ramdisk', open(mfns[0]))
            setattr(namespace, 'second', open(_prefix+'-second'))
            setattr(namespace, 'dt', open(_prefix+'-dt'))
            setattr(namespace, 'os_patch_level', parse_os_patch_level(_dict.get('os_patch_level')))
            setattr(namespace, 'os_version', parse_os_version(_dict.get('os_version')))

        except (IOError, ValueError):
            _dict = {}
        pprint.pprint(namespace.__dict__, indent =4)


class RAMDISKAction(Action):
    """An argparse action that concatenates "--ramdisk" "ramdisk" """

    def __call__(self, parser, namespace, value, name):
        _fd = None
        if os.path.isdir(value):
            #_curdir = os.getcwd()

            print(value)
            _fn = os.path.split(value)[0]
            _fd = open(_fn+'.gz', 'wb')
            #os.chdir(value)
            p1 = Popen([join(getscript(), "mkbootfs"), "-f", join(getscript(), "etc/boot_filesystem_config.txt"), _fn], stdout=PIPE)
            p2 = Popen([join(getscript(), "minigzip")], stdin=p1.stdout, stdout=_fd)
            output = p2.communicate()[0]

            #os.chdir(_curdir)
            _fd.flush()

            """unset gzip timestamp, gzip head 4->8"""
            #_fd.seek(4)
            #_fd.write(pack('4x'))
            """unset timestamp end"""

            _fd.close()
            _fd = open(_fn+'.gz', 'rb')
            setattr(namespace, self.dest, _fd)

def update_ramdisk(args):
    _fd = None
    value=args.ramdisk
    if os.path.isdir(value):
        #_curdir = os.getcwd()

        print(value)
        _fn = os.path.split(value)[0]
        _fd = open(_fn+'.gz', 'wb')
        #os.chdir(value)
        p1 = Popen([join(getscript(), "mkbootfs"), "-f", join(getscript(), "etc/boot_filesystem_config.txt"), _fn], stdout=PIPE)
        p2 = Popen([join(getscript(), "minigzip")], stdin=p1.stdout, stdout=_fd)
        output = p2.communicate()[0]
        print(output)

        #os.chdir(_curdir)
        _fd.flush()

        """unset gzip timestamp, gzip head 4->8"""
        #_fd.seek(4)
        #_fd.write(pack('4x'))
        """unset timestamp end"""

        _fd.close()
        _fd = open(_fn+'.gz', 'rb')
        setattr(args, 'ramdisk', _fd)

def write_str_to_file(filename, s):
    with open(filename, 'wb') as f:
        f.write(s.encode())

def is_arm64(filename):
    data = None
    with open(filename, 'rb') as f:
        fmt = '24s'
        size = calcsize(fmt)
        buf = f.read(size)
        if(len(buf))!=size:
            return False
        data = unpack(fmt, buf)

    return data[0]==ARMV8MAGIC

def root_action(args):
    print(args.ramdisk)
    print(join(dirname(args.ramdisk),'sbin/init'))
    shutil.copy2(join(getscript(), 'ramdisk/init.lucha.rc'), join(dirname(args.ramdisk),'init.lucha.rc'))
    _rc_fn=join(dirname(args.ramdisk),'init.rc')
    _fd_rc=open(_rc_fn, 'rb')
    init_rc_str=''
    try:
        done=False
        for line in _fd_rc:
            if 'import /init.lucha.rc' in line:
                done=True
            if not done and 'import /init.environ.rc' in line:
                init_rc_str += 'import /init.lucha.rc\n'
            init_rc_str +=line
        _fd_rc.close()
        with open(_rc_fn, 'wb') as f:
            f.write(init_rc_str.encode())
        f.close()
    finally:
        _fd_rc.close()
    suffix='marmv7-8'
    if is_arm64(join(dirname(args.ramdisk), 'init')):
        suffix='marmv8-8'
    if args.sign == '':
        shutil.copy2(join(getscript(), 'security', 'verity_key'), join(dirname(args.ramdisk),'verity_key'))
    shutil.copy2(join(getscript(), 'ramdisk/sbin/adbd%s' %(suffix)), join(dirname(args.ramdisk),'sbin/adbd'))
    shutil.copy2(join(getscript(), 'ramdisk/sbin/init%s' %(suffix)), join(dirname(args.ramdisk),'sbin/init'))
    shutil.copy2(join(getscript(), 'ramdisk/sbin/su.cil'), join(dirname(args.ramdisk),'sbin/su.cil'))
    shutil.copy2(join(getscript(), 'ramdisk/sbin/dontauditsu.cil'), join(dirname(args.ramdisk),'sbin/dontauditsu.cil'))
    shutil.copy2(join(getscript(), 'ramdisk/sbin/init.sh'), join(dirname(args.ramdisk),'sbin/init.sh'))

def parse_cmdline():
    parser = ArgumentParser()

    parser.add_argument('-i', '--input', help='input bootimg.json file name', type=FileType('rb'), action=JSONAction,
                        required=True)
    parser.add_argument('-l', '--level',  help='Root Android Level, 0: only re-pack, 1: only adbd permissive,  2: full permissive', type=parse_int,
                                   choices=[i for i in range(0,3)], default=0)
    parser.add_argument('-s', '--sign',  help='signing boot image type, default will disable dm-verity, such as Petito or U50APLUSTMO', type=str,
                                   default='')
    parser.add_argument('-d', '--disable_verity',  help='disable dm-verity checking when verity system/vendor verity table signature fail',
                                   action='store_true')
    parser.add_argument('--ramdisk', help='path to the dir ramdisk', type=str)
    parser.add_argument('--kernel', help='path to the kernel', type=FileType('rb'),
                        required=False)
    parser.add_argument('--second', help='path to the 2nd bootloader', type=FileType('rb'))
    parser.add_argument('--cmdline', help='extra arguments to be passed on the '
                        'kernel command line', default='', action=ValidateStrLenAction, maxlen=1536)
    parser.add_argument('--base', help='base address', type=parse_int, default=0x10000000)
    parser.add_argument('--kernel_offset', help='kernel offset', type=parse_int, default=0x00008000)
    parser.add_argument('--ramdisk_offset', help='ramdisk offset', type=parse_int, default=0x01000000)
    parser.add_argument('--second_offset', help='2nd bootloader offset', type=parse_int,
                        default=0x00f00000)
    parser.add_argument('--os_version', help='operating system version', type=parse_os_version,
                        default=0)
    parser.add_argument('--os_patch_level', help='operating system patch level',
                        type=parse_os_patch_level, default=0)
    parser.add_argument('--tags_offset', help='tags offset', type=parse_int, default=0x00000100)
    parser.add_argument('--board', help='board name', default='', action=ValidateStrLenAction,
                        maxlen=16)
    parser.add_argument('--pagesize', help='page size', type=parse_int,
                        choices=[2**i for i in range(11,18)], default=2048)
    parser.add_argument('--id', help='print the image ID on standard output',
                        action='store_true')
    parser.add_argument('--dt', help='path to the device tree image', type=FileType('rb'))
    parser.add_argument('-o', '--output', help='output file name', type=FileType('wb'),
                        required=True)
    return parser.parse_args()


def write_data(args):
    write_padded_file(args.output, args.kernel, args.pagesize)
    write_padded_file(args.output, args.ramdisk, args.pagesize)
    write_padded_file(args.output, args.second, args.pagesize)
    write_padded_file(args.output, args.dt, args.pagesize)

def main():
    args = parse_cmdline()
    if args.level:
        if args.level == 2:
            args.cmdline += " androidboot.selinux=permissive"
        args.cmdline += " printk.disable_uart=0"
        args.cmdline += " rdinit=/sbin/init"
        if args.disable_verity or args.sign == '':
            args.cmdline += " androidboot.verifiedbootstate=orange"
        args.cmdline += " -- "
        root_action(args)
    if isinstance(args.ramdisk, str):
        update_ramdisk(args)
    pprint.pprint(args.__dict__, indent =4)
    img_id = write_header(args)
    write_data(args)
    args.output.flush()
    args.output.close()
    #qcom 
    if args.sign == '':
        retcode = call([join(getscript(), 'boot_signer'), '/boot', os.path.abspath(args.output.name), \
            join(getscript(), 'security', 'verity.pk8'), join(getscript(), 'security', 'verity.x509.pem'), os.path.abspath(args.output.name)])
    else:
        retcode = call([join(getscript(), 'jrdsz_sign_tool/st.sh'), args.sign, '0', 'boot', os.path.abspath(args.output.name)])
    #retcode = call([join(getscript(), 'jrdsz_sign_tool/st.sh'), 'Pepito', '0', 'boot', os.path.abspath(args.output.name)])
    if args.id:
        if isinstance(img_id, str):
            # Python 2's struct.pack returns a string, but py3 returns bytes.
            img_id = [ord(x) for x in img_id]
        print('0x' + ''.join('{:02x}'.format(c) for c in img_id))

if __name__ == '__main__':
    main()
